# SOLID(좋은 객체 지향 설계의 5가지 원칙) 

## SOLID란?
클린코드로 유명한 로버트 마틴이 `좋은 객체 지향 설계의 5가지 원칙`을 정리한 것 
1. SRP : 단일 책임 원칙
2. OCP : 개방-폐쇄 원칙
3. LSP : 리스코프 치환 원칙
4. ISP : 인터페이스 분리 원칙
5. DIP : 의존관계 역전 원칙 

<br/>


## SRP(Single Responsibility Principle) 
1. 한 클래스는 `하나의 책임`만 가져야 함 
2. 하나의 책임이라는 것은 모호, 클 수 있고 작을수도 있으며 문맥과 상황에 따라 다름 
3. 중요한 기준은 변경, 변경이 있을 때 하나의 클래스만 변경되면 굉장히 잘 지킨 것 <br/>
> 하나의 클래스 안에 DB, SQL 쿼리문, View ...... 최악! 

<br/>


## OCP(Open/closed principle)
### OCP란 
1. 소프트웨어 요소는 `확장`에는 열려 있으나 `변경`에는 닫혀 있어야 함
2. 다형성의 예(역할과 구현의 분리)에서 하나의 역할을 잘 지키는 새로운 구현체를 만들게 되면? <br/>
> 기존 코드는 `변경`되지 않고, 새로운 기능을 `확장`시킬 수 있음

### OCP 문제점 
```java
public class MemberService {
  //private MemberRepository memberRepositry = new MemoryMemberRepository(); 
  private MemberRepository memberRepositry = new JdbcMemberRepositry(); 
}
```
1. 위의 예시에서 MemberService 클라이언트가 구현 클래스를 직접 선택하고 있음 
2. 이렇게 되면 구현 객체를 변경할 때 클라이언트 코드를 변경해야 함 
3. 다형성을 사용했지만 OCP 원칙을 지킬 수 없음 <br/>
> 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, `설정자`가 필요.. `Spring Container` 

<br/>

## LSP(Liskov Substitution Principle)
1. 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함 
2. 다형성에서 하위 클래스는 `인터페이스 규약`을 다 지켜야 한다는 것, 구현체를 믿고 사용하기 위해서는 이 원칙이 꼭 필요 
3. 자동차 인터페이스에서 엑셀이라는 메서드가 앞으로 가는 기능이라는 규약을 가지고 있다고 하면 이를 구현하는 모든 엑셀은 이 규약을 지켜야 함

<br/>

## ISP(Interface Segregation Principle) 
1. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음 
2. 만약 자동차 인터페이스를 운전, 정비 인터페이스로 분리하고 사용자 클라이언트를 운전자, 정비사 클라이언트로 분리하게 되면 
3. 정비 인터페이스가 변경디면 운전자 클라이언트에 영향을 주지 않음 
4. 인터페이스가 `명확`해지고, `대체 가능성`이 높아짐 

<br/>

## DIP(Dependency Inversion Principle) 
1. 프로그래머는 `추상화`에 의존해야지, `구체화`에 의존하면 안됨 
2. 클라이언트 코드가 `인터페이스`만 알고 있으면 된다는 의미 
3. 만약 로미오 역할을 맡은 배우가 줄리엣 역할과 합을 맞추는 것이 아닌 줄리엣 역할을 맡은 특정 배우하고만 합을 맞추게 되면 줄리엣 역할 배우를 대체할 수 있는 가능성이 낮아짐 
4. 위의 소스 예제에서 MemberService 클라이언트가 코드를 직접 선택하는 것은 DIP 위반(구현 클래스를 직접 `선택(의존)`하기 때문) 
5. `역할`에 의존하게 해야 한다는 것과 같음 

<br/>

## 정리 
1. 객체 지향의 핵심은 다형성 
2. 하지만 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없음
3. 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드고 함께 변경됨 
4. 다형성 만으로는 `OCP`, `DIP`를 지킬 수 없음
