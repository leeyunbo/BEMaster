# TCP, UDP
## 인터넷 프로토콜 스택의 4계층 
![DFB238CC-2A58-48AC-A51F-E72E4DD30B1A](https://user-images.githubusercontent.com/44944031/107947416-b2001880-6fd5-11eb-8abe-954d94af00cc.png)
* IP위에 TCP, UDP를 얹어 보완해준다는 느낌 

#### 프로토콜 계층 
![B0D3E131-3AD0-4767-81F9-C61D7CE46A6E](https://user-images.githubusercontent.com/44944031/107947338-998ffe00-6fd5-11eb-98ce-a8e0c4c330bd.png)
1. 소켓 라이브러리를 통해 전달
2. TCP가 TCP 정보를 생성하여 메시지를 감쌈
3. IP 정보를 생성하여 메시지를 또 감쌈 
4. 마지막으로 랜카드를 통해 출발할 때 이더넷 프레임(물리적인 정보)를 포함하여 전송함 

#### IP 패킷 정보 
* 출발지IP, 목적지IP, 기타…
* 전송 데이터 

#### TCP/IP 패킷 정보 
![D97C1938-0A5C-4E18-9762-FF3A212CBAD4](https://user-images.githubusercontent.com/44944031/107947343-9b59c180-6fd5-11eb-80e4-8306c1b127de.png)
* IP 패킷 정보 + TCP 정보 
* TCP 정보(출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보…) 
-> IP 만으로 해결이 안됐던 것이 해결됨 

<br/>

## TCP 특징 
1. 전송 제어 프로토콜 
* 연결 지향 프로토콜 - TCP 3 way handshake (상대방이 연결된 것을 확인) 
-> 얘는 논리적으로 연결된 것, 진짜 물리적으로 연결된 것을 확인하는 것이 아닌  단순히 메시지를 주고 받았음으로 ‘아 연결은 되어있구나’라고 생각하는 것 
* 데이터 전달 보증 (누락되어도 알 수 있음)  
* 순서 보장 
2. 신뢰할 수 있는 프로토콜 
3. 현재는 대부분 TCP 사용 

#### TCP 3 way handshake 
![04FA9315-9128-49C0-9C21-98D10EC0E821](https://user-images.githubusercontent.com/44944031/107947363-a01e7580-6fd5-11eb-9a2f-a0013abfff59.png)
1. 클라이언트 : SYN 메시지를 보냄 
2. 서버 : SYN + ACK 메시지를 반환함 
3. 클라이언트 : ACK 메시지를 반환함 
4. 이렇게 하면 서로를 믿을 수 있음 (ACK 반환이 없으면 아~ 연결에 실패했구나) 
`ACK : 요청 수락, SYN : 접속 요청`

#### 데이터 전달 보증 
* 데이터를 전송하면 서버에서 데이터를 잘 받았다고 응답 메시지를 보냄 
* 따라서 클라이언트가 전송된 것을 인지할 수 있음 

#### 순서 보장 
* 서버가 1,3,2 순서로 받게 되면 다 버리고 2번부터 다시 보내라고 응답 메시지를 보냄 
* 응답 메시지를 수신한 클라이언트는 2번부터 다시 보냄 

<br/> 

## UDP 특징 
1. 사용자 데이터그램 프로토콜 
* 하얀 도화지에 비유(기능이 거의 없음) 
* 연결지향X
* 데이터 전달 보증X
* 순서 보장X
* 단순하고 빠른 것이 장점 
-> IP 프로토콜과 매우 유사하지만 포트와 체크섬 정도만 추가 
-> 어플리케이션에서 추가 작업이 필요 
