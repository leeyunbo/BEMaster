# HTTP 헤더 - 캐시와 조건부 요청 
## 캐시의 동작 
#### 1. 캐시가 없을 때  
* 어떠한 이미지를 요청 GET 
* 서버는 해당 이미지를 응답 
* 이후에 다시 같은 이미지를 요청 GET
* 서버는 해당 이미지를 또 응답 
-> 데이터가 변경되지 않아도 계속 네트워크를 통해 해당 데이터를 다운로드 받아야 함 
-> 브라우저 로딩 속도가 느려져, 사용자는 느린 경험을 하게 됨 

#### 2. 캐시 적용 
* 어떠한 이미지를 요청 GET  
* 서버가 이미지를 응답, 응답 메시지의 캐시 관련 헤더를 통해 브라우저는 브라우저 캐시에 저장 
* 이후 클라이언트 요청 시 우선적으로 브라우저 캐시를 살펴봄 
-> 캐시 덕분에 네트워크를 사용하지 않아 브라우저 로딩 속도가 빠름 
* 캐시 시간이 초과 된 경우? 
-> 당연히 다시 요청 후 같은 과정 반복 
-> 서버 데이터와 캐시 데이터가 같은 경우 굳이 또 받아올 필요가 있을까…? 

## 검증 헤더와 조건부 요청 
#### 1. 검증 헤더를 추가 한 경우 
* 어떠한 이미지를 요청 GET 
* 응답 메시지에 Last-Modified(최종 수정일, 검증헤더) 추가 
* 브라우저는 응답 결과를 캐시에 저장 후 최종 수정일을 함께 기록 
* 캐시 시간 초과 후 요청할 때 최종 수정일이 있는 경우 요청 헤더에 최종 수정일을 저장(if-modified-since, 조건부 요청 헤더)하여 함께 전송 
* 서버는 자신이 가지고 있는 수정일과 비교하여 검증한 후 304 Not Modified라는 결과를 응답함 (Last- Modified 포함, HTTP Body가 없음) 
-> 헤더의 크기는 굉장히 작기 때문에 효율적임  
* 웹 브라우저는 캐시 갱신, 최종 수정일 갱신하여 캐시 데이터를 재사용함 
-> 네트워크 다운로드는 발생하지만 용량이 적은 헤더 정보만 다운로드! 

## 검증 헤더와 조건부 요청 - ETag 
#### 1. Last-Modified, If-Modified-Since 단점 
* 1초 미만 단위로 캐시 조정 불가 (최대 초 단위) 
* 날짜 기반의 정해진 로직 사용 
->  데이터를 수정하여 날짜가 다르지만, 결국에 데이터 결과가 똑같은 경우에는? 

#### 2. Etag, If-None-Match 
* 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠 (Etag: “v1.0”)
* 해시 ( 파일 콘텐츠가 동일하면 해시는 동일한 결과를 반환함 )
* *Etag만 보내서 같으면 유지, 다르면 다시 받기 로직* 

#### 3. Etag 사용 
* 임의의 이미지를 요청 
* 서버에서 Etag 포함하여 반환, 클라이언트는 Etag 함께 캐시에 저장 
* 다음 요청에서 Etag(If-None-Match)를 포함하여 서버에게 요청 
* 서버는 Etag가 같으면 304 Not Modified 반환 + HTTP Body가 없음 
* 응답 결과를 재사용, 헤더 데이터 갱신 

#### 4. 정리 
* 캐시 제어 로직을 서버에서 완전히 관리 
* 클라이언트는 단순히 이 값을 서버에게 제공하는 것 

## 캐시와 조건부 요청 헤더 정리 
#### 1. 캐시 제어 헤더 (Cache-Control) 
* Cache-Control: max-age (캐시 유효 시간, 초 단위) 
* Cache-Control: no-cache (데이터는 캐시해도 되지만, 이 캐시를 쓰기 전에 원(Origin) 서버에게 무조건 검증(바꼈는지)을 받아야함) 
* Cache-Control: no-store (데이터에 민감한 정보가 있으므로 저장X, 하드디스크가 아닌 메인 메모리에서 사용하고 빨리 삭제) 

#### 2. 캐시 제어 헤더 (Pragma) 
* 사용 X

#### 3. 캐시 제어 헤더 (Expires) 
* 초단위로 지정하는 것이 아닌 삭제 될 시간을 정확히 지정할 수 있음
* cache-control이 좀 더 유연하여 권장됨  

## 프록시 캐시 
#### 1. 프록시 캐시 도입 
[image:F70D9F65-3EF7-46DA-B156-32D315391C96-346-00003F83290A97E0/D29A6A6F-5397-4BC6-8D7F-F1955E80CD47.png]

* 미국에 원서버가 있는 경우 응답이 굉장히 느림 
* 한국 어딘가에 프록시 캐시 서버를 둬서 빠르게 응답할 수 있도록 함  Ex) 유튜브 한국 컨텐츠는 굉장히 빠른 반면에 잘 보지 않는 외국 컨텐츠는 느림.. 
* 최초로 요청하는 유저는 원 서버에서 받아오기에 느리지만 다음 유저부터는 프록시 서버를 통해 받기에 빠름 
* 프록시 서버의 캐시는 public(공용) 캐시, 브라우저 캐시는 private(개인) 캐시 

#### 2. Cache-Controle 캐시 지시어 
* Cache-Control : public (public에 저장 가능) 
* Cache-Control : private (private에만 저장 가능)

## 캐시 무효화 
#### 1. Cache-Control 확실한 캐시 무효화 응답 
* 보통 브라우저가 알아서 캐시를 해버리는 경우가 있음 
* 정말로 캐시가 안되는 경우 응답마다 넣어야함 
* Cache-Control: no-cache, no-store, must-revalidate
* HTTP 1.0인 경우 Pragma: no-cache

#### 2. Cache-Controle 확실한 캐시 무효화 응답 캐시 지시어 
* Cache-Control: no-cache (원 서버에 검증) 
* no-store  (저장 하지마) 
* must-revalidate (캐시 만료후 최초 조회시 원 서버에 검증) 
* Pragma: no cache (Http 1.0 하위 호환) 

#### 3. no-cache vs must-revalidate
* no-cache : 요청을 프록시서버가 원서버로 무조건 넘김 
-> 만약 원서버와 프록시서버 사이에 네트워크 단절시 원 서버 접근 불가 
-> 오류가 나는 것보다 오래된 데이터라도 보여줘야 하는 경우? 
-> no-cache는 단절된 경우 설정을 해놓으면 프록시 캐시가 응답을 할 수 있음 
* must-revalidate 
-> 단절된 경우? 
-> 무조건 504 Gateway Timeout을 프록시 서버가 응답함
-> 통장 잔고 같은 경우 옛날 데이터를 응답해주는 것은 말이 안됨 ㅋㅋ

 

 
